/* */

flwrorExpr! [in_context in_c] >[out_context out_c]:
	  #(AST_ORDER_BY orderByClause[in_c] >[out_c] flwrExprOrderBy)
	| flwrExpr[in_c] >[out_c]
;

flwrExpr! [in_context in_c] >[out_context out_c]:
	<<bool isFor=false;
	  out_context _out_c1_, _out_c2_, _out_c3_;
	>>

	#(AST_BOUND (  #(AST_FOR #(AST_VAR_DECL v1:vardecl ev1:expr[in_c] >[_out_c1_] {st1:sequenceType}) {v2:vardecl})
                       <<isFor=true;>>

                      | #(AST_LET #(AST_VAR_DECL v3:vardecl ev2:expr[in_c] >[_out_c2_] {st2:sequenceType})))

                     e:expr[in_c] >[_out_c3_])
	<<
	  if(isFor){ //LR for forClause
	    SORASTBase *iter_seq=NULL, *var_decl=NULL, *pos_decl=NULL;

	    if(v2!=NULL){
	      pos_decl=#(#["xs:integer"], v2);
	      iter_seq=#(#["con-gen1"], ev1, #["m"]); //last param must be a number, but it's value is not defined in Logical Reperesentation yet
	    }
	    else{
	      pos_decl=NULL;
	      iter_seq=ev1;
	    }

	    if(st1!=NULL){
	      var_decl=st1;
	      var_decl->append(v1);
	      var_decl=#(#[], var_decl);
	    }
	    else{
	      var_decl=#(#["xs:anyType"], v1);
	    }

	    #flwrExpr=#(#["return"], iter_seq,
                        #(#["fun-def"],
                          #(#[], var_decl, pos_decl),
                          e)
                       );
	  }// end LR for forClause
	 
          else{ //LR for letClause
	    SORASTBase *var_decl=NULL;

	    if(st2!=NULL){
	      var_decl=st2;
	      var_decl->append(v1);
	    }
	    else{
	      var_decl=#(#["xs:anyType"], v3);
	    }
	    //#flwrExpr=#(#["let@"],
	    //            #(#[], var_decl, ev2),
            //            e
            //           );
	    #flwrExpr=#(#["let@"], 
	                ev2,
	                #(#["fun-def"], #(#[], var_decl), e));

	  }// end LR for letClause

	 if( _out_c1_ > _out_c2_)
	    out_c = max_out_context (_out_c1_, _out_c3_);
	 else
	    out_c = max_out_context (_out_c2_, _out_c3_);
	>>
;


flwrExprOrderBy!:
	AST_FUNC
;

orderByClause! [in_context in_c] >[out_context out_c]:
	  #(AST_ORDER_BY (orderSpec[in_c] >[out_c])*)
	| #(AST_STABLE_ORDER_BY (orderSpec[in_c] >[out_c])*)
;

orderSpec! [in_context in_c] >[out_context out_c]:
	<<out_context out_c;>>
	#(AST_ORDER_SPEC exprSingle[in_c] >[out_c] orderModifier)
;

orderModifier!:
	#(AST_ORDER 
	  #(AST_ASC_DESC {p1:AST_ORDER_PROPERTY})
	  #(AST_EMPT_GR_LST {p2:AST_ORDER_PROPERTY})
	  #(AST_COLLATION {p3:AST_ORDER_PROPERTY})
	)
	<<#orderModifier=#["ordermodifier"];

	  if(p1!=NULL) 
	    #orderModifier->addChild(#(#["const"], 
	                               #(#["type"], 
	                                 #["!xs!string"]),
	                                 #[p1->getText()]));

	  if(p2!=NULL) 
	    #orderModifier->addChild(#(#["const"], 
	                               #(#["type"], 
	                                 #["!xs!string"]),
	                                 #[p2->getText()]));

	  if(p3!=NULL) 
	    #orderModifier->addChild(#(#["collation"],
	                               #(#["const"], 
	                                 #(#["type"], 
	                                   #["!xs!string"]),
	                                   #[p3->getText()])));

	  
	>>
;
