/* */

arithmLogicalTypeExpr![in_context in_c] >[out_context out_c]:
	  <<out_context _out_c1_, _out_c2_;>>

	  #(op:AST_B_OP eb1:expr[in_c] >[_out_c1_] eb2:expr[in_c] >[_out_c2_])
	  <<
	    #arithmLogicalExpr=
	        #(#[std::string(op->getText())+"@"], eb1, eb2);


	    if ( _out_c1_ > _out_c2_ )
	       out_c = _out_c1_;
            else
	       out_c = _out_c2_; 
	  >>
	| #(op:AST_UNARY_OP eu:expr[in_c] >[out_c])
	  <<#arithmLogicalExpr=
	        #(#[std::string(op->getText())+"@"], eu);
	  >>
	| #(AST_INSTANCE_OF ioe:expr[in_c] >[out_c] stio:sequenceType)
	  <<#arithmLogicalExpr=
	        #(#["instance-of"], ioe, #(#["type"], stio));
	  >>
	| #(AST_CAST ce:expr[in_c] >[out_c] st:singleType)
	  <<#arithmLogicalExpr=
	       #(#["cast"], ce, #(#["type"], st));
	  >>
	| #(AST_CASTABLE cas:expr[in_c] >[out_c] stc:singleType)
	  <<#arithmLogicalExpr=
	       #(#["castable"], cas, #(#["type"], stc));
	  >>

	| #(AST_TREAT te:expr[in_c] >[out_c] tst:sequenceType)
	  <<#arithmLogicalExpr=
	       #(#["treat"], te, #(#["type"], tst));
	  >>

	| rpe:relativePathExpr[in_c] >[out_c]

	  <<#arithmLogicalExpr=rpe;>>
;
